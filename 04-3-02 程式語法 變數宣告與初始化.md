# 04-3-02 程式語法 變數宣告與初始化

## 前言提要

* Ref. [資料來源](https://www.cnblogs.com/howDo/archive/2013/04/13/GoLang-Variable.html)

## 變數宣告

* 使用 `var` 宣告變數後不允許改變其形態。
* 宣告變數有多種形態：
	* 宣告一個 int 類型變數 `var a int` 
	* 宣告一個 結構體
		```
		var b struct {
			name string
		}
	  	```
	* 宣告變數同時賦值 編譯器自動判斷類型 `var a = 8`
	* 宣告變數同時賦值 `var a int = 8`
	* 批量宣告變數 簡潔
		```
		var {
			a int
			b string
		}
		```

## 變數初始化
* 宣告變數時進行初始化，也可以先宣告後初始化， 此時 `var` 關鍵字不再是必須
	* 在函式中，臨時宣告變數 + 賦值
		> var tmpStr = "" <br>
		> var tmpStr string = "" <br>
		> tmpStr := "" <br>
	* 全域變數宣告直接賦值
		> tmpStr = "body"
* 常見兩種方式。
	* `var name = value` 或 `var name type = value`
			* 如果不寫 type，則在編譯時會根據 value 判斷類型
	* `name := value`
		* 簡易宣告方式 省略 var，可以少寫代碼。
		* 賦值決定變數型態。
			* `value := 8`    => value 是 int 型態
			* `value := 8.0`  => value 是 float64 型態
* 思考問題
	* 檢測型態
	```
	package main

	import (
		"fmt"
		"reflect"
	)

	func main() {
		var v1 int = 8
		var v2 byte = 8
		v3 := 8
		v4 := 8.0

		fmt.Println("v1 type : %s\n", reflect.TypeOf(v1))      // int
		fmt.Println("v2 type : %s\n", reflect.TypeOf(v2))      // uint8
		fmt.Println("v3 type : %s\n", reflect.TypeOf(v3))      // int
		fmt.Println("v4 type : %s\n", reflect.TypeOf(v4))      // float64
	}
	```

* 常數表示式 Ref.[官方文件](http://golang.org/ref/spec#Constant_expressions)
	* const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)
	* const b = 15 / 4           // b == 3     (untyped integer constant)
	* const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)
	* const Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)
	* const Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)
	* const d = 1 << 3.0         // d == 8     (untyped integer constant)
	* const e = 1.0 << 3         // e == 8     (untyped integer constant)
	* const f = int32(1) << 33   // f == 0     (type int32)
	* const g = float64(2) >> 1  // illegal    (float64(2) is a typed floating-point constant)
	* const h = "foo" > "bar"    // h == true  (untyped boolean constant)
	* const j = true             // j == true  (untyped boolean constant)
	* const k = 'w' + 1          // k == 'x'   (untyped rune constant)
	* const l = "hi"             // l == "hi"  (untyped string constant)
	* const m = string(k)        // m == "x"   (type string)
	* const Σ = 1 - 0.707i       //            (untyped complex constant)
	* const Δ = Σ + 2.0e-4       //            (untyped complex constant)
	* const Φ = iota*1i - 1/1i   //            (untyped complex constant)
	* const ic = complex(0, c) // ic == 3.75i (untyped complex constant)
	* const iΘ = complex(0, Θ)   // iΘ == 1.5i   (type complex128)
	* const Huge = 1 << 100
	* // Huge == 1267650600228229401496703205376 (untyped integer constant)
	* const Four int8 = Huge >> 98  // Four == 4      (type int8)
	* ^1 // untyped integer constant, equal to -2
	* uint8(^1)  // illegal: same as uint8(-2), -2 cannot be represented as a uint8
	* ^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)
	* int8(^1)   // same as int8(-2)
	* ^int8(1)   // same as -1 ^ int8(1) = -2

* 額外補充例子：
	* C# 編譯錯誤，Go 語言可以編譯
		```
		// 不能編譯
		func main() {
			v1 := 8
			v1 := 8.2      // 編譯錯誤 : 常數 8.2 轉成 整數有誤
		}


		// 可以編譯
		func main() {
			v1 := 8
			v1 = 8.0       // 編譯可通過，執行無錯誤
			fmt.Println(v1)
		}
		```
	* Go 不損失精度情況下，會將 8.0 這類浮點數作為 整數 8
	* Go 的常數是高精度數
		* 有類型：`uint8` 類型顯示指定了，在表達式裡面不會變化。 
		* 無類型：分成 無類型整數 和 無類型浮點 兩類。在使用時會根據上下文需要的類型主換為實際類型，
			* uint8(0) + 1.0  =>  uint8(1)
			* uint8(0) + 1.2  =>  由於 1.2 無法轉為 uint8 而報錯
			* 如果上下文無法確定 (比如：i, j := 1, 2.0)
				* 整數無類型常數 轉換為 int
				* 浮點無類型常數 轉換為 float64

